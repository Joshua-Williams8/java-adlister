import com.mysql.cj.jdbc.Driver; //This one does.
//import java.sql.Driver; This one doesn't work with mysql
import javax.print.attribute.standard.ReferenceUriSchemesSupported;
import java.sql.*;


public class JDBCLects {


  public static void main(String[] args) throws SQLException {
    Config config = new Config();

    //Instantiage the mys1l driver to register the builtin java driver manager.
    DriverManager.registerDriver(new Driver());

    //Connect to the database by providing the URL, user, and the password of the user we want to connect as.
    Connection connection = DriverManager.getConnection(
      config.getUrl(),
//      config.getUser(),
      "root",
      config.getPassword());
//    Notice the codeup_test_db is the database we are using and the timezone
//    Below is for making statements for mysql
    Statement statement = connection.createStatement();

//    This is for executing the steps
//    System.out.println("Delete 4th id?");
//    Should return true or false if it has been deleted or not.
//    statement.execute("DELETE FROM albums WHERE id = 4");
//This returns how many rows are affected.
//    statement.executeUpdate("INSERT INTO albums (artist, name, release_date, genre, sales) VALUES('Nelly Furtado', 'Loose', 2006, 'Dance-pop, hip hop, R&B', 12.5)");
// This returns a ResultSet Object
//    This is mainly for select queries
//    statement.executeQuery("SELECT * FROM albums");

//    Handling the results with the ResultSet object
//    Below is red because we are in adlister.
    String selectQuery = "SELECT * FROM albums";

    ResultSet resultSet = statement.executeQuery(selectQuery);

//    By calling the .next() method we can iterate over the rows.
//    Method will return as true as along as there are rows left in the results.
    while(resultSet.next()){
      // Do something with each row.
      System.out.println("Here's an album");
      System.out.println(" id: " + resultSet.getLong("id"));
      System.out.println("artist: " + resultSet.getString("artist"));
      System.out.println("name: "+ resultSet.getString("name"));
    }



    String insertQuery = "INSERT INTO albums (artist, name, release_date, genre, sales) VALUES('Nelly Furtado', 'Loose', 2006, 'Dance-pop, hip hop, R&B', 12.5)";

//      For executeUpdate method we can hae 2 arguments
//    First is the query string we want ot execute
//    2nd is the constant from the statement object.
//    This gives us access to the ID's that are AUTOMATIACLLY gerated by the database.

//    statement.executeUpdate(insertQuery, statement.RETURN_GENERATED_KEYS);

//    WE CAN THEN USE THE GETGENERATEKEYS() METHOD ON  the resultSet object which will hold any IDs, generated by the dta base.

//    ResultSet rsKeys = statement.getGeneratedKeys();

//    So this allows us to track anything that is newly inserted and be tracked by the generated keys and access the ids that were created.
//    if(rsKeys.next()){
//      System.out.println("Inserted ID: " + rsKeys.getLong(1) );
////      If we were inserting multiple statements we could use a while statement
//    }

//    Stuff below is from discord check it out.

//    Statement stmt = connection.createStatement();
//            stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
//            ResultSet rs = stmt.getGeneratedKeys();
//            rs.next();

//    public Long insert(Ad ad) {
//        String sql = String.format("insert into ads (user_id, title, description) values(%d, '%s', '%s')", ad.getUserId() ,ad.getTitle(), ad.getDescription());
//        long lastId = 0;
//        try {
//            Statement stmt = connection.createStatement();
//            stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
//            ResultSet rs = stmt.getGeneratedKeys();
//            rs.next();
//            return rs.getLong(1);
//        } catch (SQLException throwables) {
//            throwables.printStackTrace();
//        }
//        return lastId;
//    }




  }
}
